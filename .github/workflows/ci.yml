# AsyncNet CI/CD Pipeline

name: AsyncNet CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

# Minimal permissions following principle of least privilege
# 
# actions: read (not write) is CORRECT because:
# - This workflow only uses standard GitHub Actions (checkout, cache, upload-artifact)
# - It does NOT call the GitHub Actions API directly
# - Concurrency cancellation (cancel-in-progress: true) is handled by GitHub's infrastructure
# - No programmatic workflow management or API calls are performed
#
# actions: write would only be needed if the workflow:
# - Used actions/github-script to call GitHub APIs
# - Programmatically canceled other workflow runs
# - Managed workflow approvals or other Actions API operations
#
# Using read permissions reduces security blast radius while maintaining full functionality.
permissions:
  contents: read
  actions: read

# Prevent duplicate workflow runs and cancel in-progress jobs
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-test:
    runs-on: ${{ matrix.runner }}
    # Increased timeout to 45 minutes to accommodate large matrix runs with multiple
    # runners, targets, Xcode versions, and Swift versions. This reduces CI failures
    # when runners queue or tests run slowly due to system load or network conditions.
    timeout-minutes: 45
    strategy:
      fail-fast: false
      matrix:
        runner: [macos-15, macos-latest]
        target: [macos, ios, tvos]
        xcode: [16]
        swift: [6.0.1]
        build: [spm, xcode]
        # Exclude incompatible combinations
        exclude:
          - target: ios
            build: spm
          - target: tvos
            build: spm
          # macOS 14 doesn't support Xcode 16 on hosted runners
          - runner: macos-14
            xcode: 16

    steps:
      - name: Checkout code
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4

      - name: Cache SPM
        if: matrix.target == 'macos' && matrix.build == 'spm'
        uses: actions/cache@0400d5f644dc74513175e3cd8d07132dd4860809 # v4
        with:
          path: .build
          key: ${{ runner.os }}-spm-${{ matrix.swift }}-${{ hashFiles('**/Package.resolved') }}
          restore-keys: |
            ${{ runner.os }}-spm-${{ matrix.swift }}-

      - name: Cache Xcode DerivedData
        if: matrix.build == 'xcode'
        uses: actions/cache@0400d5f644dc74513175e3cd8d07132dd4860809 # v4
        with:
          path: ~/Library/Developer/Xcode/DerivedData
          key: ${{ runner.os }}-xcode${{ matrix.xcode }}-swift-${{ matrix.swift }}-deriveddata-${{ hashFiles('**/Package.resolved') }}
          restore-keys: |
            ${{ runner.os }}-xcode${{ matrix.xcode }}-swift-${{ matrix.swift }}-deriveddata-

      - name: Set up Swift (macOS SPM)
        if: runner.os == 'macOS' && matrix.target == 'macos' && matrix.build == 'spm'
        uses: swift-actions/setup-swift@682457186b71c25a884c45c06f859febbe259240 # v2.3.0
        with:
          swift-version: ${{ matrix.swift }}

      - name: Set up Xcode (macOS/iOS/tvOS)
        if: runner.os == 'macOS' && matrix.build == 'xcode'
        uses: maxim-lobanov/setup-xcode@60606e260d2fc5762a71e64e74b2174e8ea3c8bd # v1
        with:
          xcode-version: ${{ matrix.xcode }}

      - name: Validate Xcode availability
        if: runner.os == 'macOS' && matrix.build == 'xcode'
        run: |
          #!/bin/bash
          # Validate selected Xcode is available on the runner
          if ! xcodebuild -version; then
            echo "ERROR: xcodebuild -version failed. The selected Xcode version may not be available on this runner."
            exit 1
          fi

      - name: Build (macOS SPM)
        if: matrix.target == 'macos' && matrix.build == 'spm'
        run: |
          swift build --configuration Debug \
            -Xswiftc -Xfrontend -Xswiftc -strict-concurrency=complete \
            -Xswiftc -Xfrontend -Xswiftc -warn-concurrency \
            -Xswiftc -Xfrontend -Xswiftc -enable-actor-data-race-checks

      - name: Build (macOS Xcode)
        if: matrix.target == 'macos' && matrix.build == 'xcode'
        run: xcodebuild -scheme AsyncNet -destination "platform=macOS" CODE_SIGNING_ALLOWED=NO CODE_SIGNING_REQUIRED=NO build

      - name: Find iOS Simulator
        if: matrix.target == 'ios'
        id: find_ios_simulator
        run: |
          set -euo pipefail

          echo "=== iOS Simulator Discovery ==="

          # Find an available iPhone simulator and capture both name and UDID
          echo "Querying available iOS simulators..."
          if ! JSON_OUTPUT=$(xcrun simctl list --json devices available 2>/dev/null); then
            # Capture exit code and stderr immediately after the failing command
            EXIT_CODE=$?
            STDERR_OUTPUT=$(xcrun simctl list --json devices available 2>&1 >/dev/null)
            echo "ERROR: xcrun simctl list failed with exit code $EXIT_CODE"
            echo "xcrun stderr output: $STDERR_OUTPUT"
            echo "Available devices list:"
            xcrun simctl list devices available || true
            exit $EXIT_CODE
          fi

          # Validate JSON output is non-empty
          if [ -z "$JSON_OUTPUT" ]; then
            echo "ERROR: xcrun simctl list returned empty output"
            echo "Available devices list:"
            xcrun simctl list devices available || true
            exit 1
          fi

          # Check if jq is available
          if ! command -v jq >/dev/null 2>&1; then
            echo "jq is not installed, attempting to install it..."
            
            # Attempt to install jq based on the OS
            if command -v brew >/dev/null 2>&1; then
              echo "Detected macOS/Homebrew, installing jq with brew..."
              if brew update && brew install jq; then
                echo "Successfully installed jq via brew"
              else
                echo "Failed to install jq via brew"
                echo "jq is required for parsing simulator device information"
                echo ""
                echo "To install jq manually on macOS:"
                echo "  brew update && brew install jq"
                echo ""
                echo "Or add jq to your GitHub Actions runner image"
                echo ""
                echo "Available devices list:"
                xcrun simctl list devices available || true
                exit 1
              fi
            elif command -v apt-get >/dev/null 2>&1; then
              echo "Detected Linux/apt-get, installing jq with apt-get..."
              if apt-get update && apt-get install -y jq; then
                echo "Successfully installed jq via apt-get"
              else
                echo "Failed to install jq via apt-get"
                echo "jq is required for parsing simulator device information"
                echo ""
                echo "To install jq manually on Linux:"
                echo "  apt-get update && apt-get install -y jq"
                echo ""
                echo "Or add jq to your GitHub Actions runner image"
                echo ""
                echo "Available devices list:"
                xcrun simctl list devices available || true
                exit 1
              fi
            elif command -v choco >/dev/null 2>&1; then
              echo "Detected Windows/Chocolatey, installing jq with choco..."
              if choco install jq -y; then
                echo "Successfully installed jq via choco"
              else
                echo "Failed to install jq via choco"
                echo "jq is required for parsing simulator device information"
                echo ""
                echo "To install jq manually on Windows:"
                echo "  choco install jq -y"
                echo ""
                echo "Or add jq to your GitHub Actions runner image"
                echo ""
                echo "Available devices list:"
                xcrun simctl list devices available || true
                exit 1
              fi
            else
              echo "Unable to detect package manager (brew, apt-get, or choco)"
              echo "jq is required for parsing simulator device information"
              echo ""
              echo "To install jq on macOS:"
              echo "  brew update && brew install jq"
              echo ""
              echo "To install jq on Linux:"
              echo "  apt-get update && apt-get install -y jq"
              echo ""
              echo "To install jq on Windows:"
              echo "  choco install jq -y"
              echo ""
              echo "Or add jq to your GitHub Actions runner image"
              echo ""
              echo "Available devices list:"
              xcrun simctl list devices available || true
              exit 1
            fi
          fi

          echo "Parsing JSON output with jq..."
          if ! IOS_LINE=$(echo "$JSON_OUTPUT" | jq -r '
            .devices
            | to_entries[]
            | select(.key | contains("iOS"))
            | .value[]
            | select(.name | contains("iPhone"))
            | select(.isAvailable == true)
            | select(.state == "Shutdown" or .state == "Booted")
            | [.name, .udid] | @tsv' | head -1 2>/dev/null); then
            # Capture exit code and stderr immediately after the failing command
            EXIT_CODE=$?
            STDERR_OUTPUT=$(echo "$JSON_OUTPUT" | jq -r '
              .devices
              | to_entries[]
              | select(.key | contains("iOS"))
              | .value[]
              | select(.name | contains("iPhone"))
              | select(.isAvailable == true)
              | select(.state == "Shutdown" or .state == "Booted")
              | [.name, .udid] | @tsv' | head -1 2>&1 >/dev/null)
            echo "ERROR: jq parsing failed with exit code $EXIT_CODE"
            echo "jq stderr output: $STDERR_OUTPUT"
            echo "JSON output was:"
            echo "$JSON_OUTPUT"
            echo "Available devices list:"
            xcrun simctl list devices available || true
            exit $EXIT_CODE
          fi

          if [ -n "${IOS_LINE:-}" ]; then
            IOS_NAME="$(echo "$IOS_LINE" | cut -f1)"
            IOS_UDID="$(echo "$IOS_LINE" | cut -f2)"
            echo "Found available iOS simulator: '$IOS_NAME' (UDID: $IOS_UDID)"
          else
            echo "No available iOS simulators found, attempting fallback to 'iPhone 14'..."

            # Verify fallback device exists
            if ! xcrun simctl list devices available | grep -q "iPhone 14"; then
              echo "ERROR: Fallback device 'iPhone 14' not found in available simulators"
              echo "Full list of available devices:"
              xcrun simctl list devices available
              echo ""
              echo "JSON devices list:"
              echo "$JSON_OUTPUT" | jq '.devices' 2>/dev/null || echo "JSON parsing failed"
              exit 1
            fi

            IOS_NAME="iPhone 14"
            IOS_UDID=""
            echo "Using fallback iOS simulator: '$IOS_NAME'"
          fi

          if [ -n "$IOS_UDID" ]; then
            echo "Ensuring simulator is booted: $IOS_NAME ($IOS_UDID)"
            if ! xcrun simctl bootstatus "$IOS_UDID" -b 2>&1; then
              echo "Simulator not booted; attempting boot..."
              if ! xcrun simctl boot "$IOS_UDID" 2>&1; then
                echo "ERROR: Failed to boot simulator '$IOS_NAME' (UDID: $IOS_UDID)"
                xcrun simctl list devices available || true
                xcrun simctl list devices 2>/dev/null | grep -A 2 -B 2 "$IOS_NAME" || true
                exit 1
              fi
              echo "Waiting for simulator to be ready..."
              if ! xcrun simctl bootstatus "$IOS_UDID" -b 2>&1; then
                echo "ERROR: Failed to reach booted state for '$IOS_NAME' (UDID: $IOS_UDID)"
                xcrun simctl list devices available || true
                xcrun simctl list devices 2>/dev/null | grep -A 2 -B 2 "$IOS_NAME" || true
                exit 1
              fi
            fi
          else
            echo "No UDID available, skipping boot (will use platform=name format)"
          fi

          echo "ios_simulator_name=$IOS_NAME" >> "$GITHUB_OUTPUT"
          echo "ios_simulator_udid=$IOS_UDID" >> "$GITHUB_OUTPUT"
          echo "Successfully configured iOS Simulator: name='$IOS_NAME' udid='${IOS_UDID:-N/A}'"
          
      - name: Build (iOS)
        if: matrix.target == 'ios'
        run: |
          DEST=$([ -n "${{ steps.find_ios_simulator.outputs.ios_simulator_udid }}" ] && echo "id=${{ steps.find_ios_simulator.outputs.ios_simulator_udid }}" || echo "platform=iOS Simulator,name=${{ steps.find_ios_simulator.outputs.ios_simulator_name }}")
          xcodebuild -scheme AsyncNet -destination "$DEST" -sdk iphonesimulator CODE_SIGNING_ALLOWED=NO CODE_SIGNING_REQUIRED=NO build

      - name: Find tvOS Simulator
        if: matrix.target == 'tvos'
        id: find_tvos_simulator
        run: |
          set -euo pipefail

          echo "=== tvOS Simulator Discovery ==="

          # Find an available Apple TV simulator and capture both name and UDID
          echo "Querying available tvOS simulators..."
          if ! JSON_OUTPUT=$(xcrun simctl list --json devices available 2>/dev/null); then
            # Capture exit code and stderr immediately after the failing command
            EXIT_CODE=$?
            STDERR_OUTPUT=$(xcrun simctl list --json devices available 2>&1 >/dev/null)
            echo "ERROR: xcrun simctl list failed with exit code $EXIT_CODE"
            echo "xcrun stderr output: $STDERR_OUTPUT"
            echo "Available devices list:"
            xcrun simctl list devices available || true
            exit $EXIT_CODE
          fi

          # Validate JSON output is non-empty
          if [ -z "$JSON_OUTPUT" ]; then
            echo "ERROR: xcrun simctl list returned empty output"
            echo "Available devices list:"
            xcrun simctl list devices available || true
            exit 1
          fi

          # Check if jq is available
          if ! command -v jq >/dev/null 2>&1; then
            echo "jq is not installed, attempting to install it..."
            
            # Attempt to install jq based on the OS
            if command -v brew >/dev/null 2>&1; then
              echo "Detected macOS/Homebrew, installing jq with brew..."
              if brew update && brew install jq; then
                echo "Successfully installed jq via brew"
              else
                echo "Failed to install jq via brew"
                echo "jq is required for parsing simulator device information"
                echo ""
                echo "To install jq manually on macOS:"
                echo "  brew update && brew install jq"
                echo ""
                echo "Or add jq to your GitHub Actions runner image"
                echo ""
                echo "Available devices list:"
                xcrun simctl list devices available || true
                exit 1
              fi
            elif command -v apt-get >/dev/null 2>&1; then
              echo "Detected Linux/apt-get, installing jq with apt-get..."
              if apt-get update && apt-get install -y jq; then
                echo "Successfully installed jq via apt-get"
              else
                echo "Failed to install jq via apt-get"
                echo "jq is required for parsing simulator device information"
                echo ""
                echo "To install jq manually on Linux:"
                echo "  apt-get update && apt-get install -y jq"
                echo ""
                echo "Or add jq to your GitHub Actions runner image"
                echo ""
                echo "Available devices list:"
                xcrun simctl list devices available || true
                exit 1
              fi
            elif command -v choco >/dev/null 2>&1; then
              echo "Detected Windows/Chocolatey, installing jq with choco..."
              if choco install jq -y; then
                echo "Successfully installed jq via choco"
              else
                echo "Failed to install jq via choco"
                echo "jq is required for parsing simulator device information"
                echo ""
                echo "To install jq manually on Windows:"
                echo "  choco install jq -y"
                echo ""
                echo "Or add jq to your GitHub Actions runner image"
                echo ""
                echo "Available devices list:"
                xcrun simctl list devices available || true
                exit 1
              fi
            else
              echo "Unable to detect package manager (brew, apt-get, or choco)"
              echo "jq is required for parsing simulator device information"
              echo ""
              echo "To install jq on macOS:"
              echo "  brew update && brew install jq"
              echo ""
              echo "To install jq on Linux:"
              echo "  apt-get update && apt-get install -y jq"
              echo ""
              echo "To install jq on Windows:"
              echo "  choco install jq -y"
              echo ""
              echo "Or add jq to your GitHub Actions runner image"
              echo ""
              echo "Available devices list:"
              xcrun simctl list devices available || true
              exit 1
            fi
          fi

          echo "Parsing JSON output with jq..."
          if ! TVOS_LINE=$(echo "$JSON_OUTPUT" | jq -r '
            .devices
            | to_entries[]
            | select(.key | contains("tvOS"))
            | .value[]
            | select(.name | contains("Apple TV"))
            | select(.isAvailable == true)
            | select(.state == "Shutdown" or .state == "Booted")
            | [.name, .udid] | @tsv' | head -1 2>/dev/null); then
            # Capture exit code and stderr immediately after the failing command
            EXIT_CODE=$?
            STDERR_OUTPUT=$(echo "$JSON_OUTPUT" | jq -r '
              .devices
              | to_entries[]
              | select(.key | contains("tvOS"))
              | .value[]
              | select(.name | contains("Apple TV"))
              | select(.isAvailable == true)
              | select(.state == "Shutdown" or .state == "Booted")
              | [.name, .udid] | @tsv' | head -1 2>&1 >/dev/null)
            echo "ERROR: jq parsing failed with exit code $EXIT_CODE"
            echo "jq stderr output: $STDERR_OUTPUT"
            echo "JSON output was:"
            echo "$JSON_OUTPUT"
            echo "Available devices list:"
            xcrun simctl list devices available || true
            exit $EXIT_CODE
          fi

          if [ -n "${TVOS_LINE:-}" ]; then
            TVOS_NAME="$(echo "$TVOS_LINE" | cut -f1)"
            TVOS_UDID="$(echo "$TVOS_LINE" | cut -f2)"
            echo "Found available tvOS simulator: '$TVOS_NAME' (UDID: $TVOS_UDID)"
          else
            echo "No available tvOS simulators found, attempting fallback to 'Apple TV 4K'..."

            # Verify fallback device exists
            if ! xcrun simctl list devices available | grep -q "Apple TV 4K"; then
              echo "ERROR: Fallback device 'Apple TV 4K' not found in available simulators"
              echo "Full list of available devices:"
              xcrun simctl list devices available
              echo ""
              echo "JSON devices list:"
              echo "$JSON_OUTPUT" | jq '.devices' 2>/dev/null || echo "JSON parsing failed"
              exit 1
            fi

            TVOS_NAME="Apple TV 4K"
            TVOS_UDID=""
            echo "Using fallback tvOS simulator: '$TVOS_NAME'"
          fi

          if [ -n "$TVOS_UDID" ]; then
            echo "Booting simulator with UDID: $TVOS_UDID"
            
            # Check if simulator is already booted
            DEVICE_STATE=$(xcrun simctl list devices 2>/dev/null | grep "$TVOS_UDID" | sed -n 's/.*(\([^)]*\)).*/\1/p' | head -1)
            echo "Current device state: ${DEVICE_STATE:-unknown}"
            
            if [ "$DEVICE_STATE" != "Booted" ]; then
              if ! xcrun simctl boot "$TVOS_UDID" 2>&1; then
                echo "ERROR: Failed to boot simulator '$TVOS_NAME' (UDID: $TVOS_UDID)"
                echo "Available devices list:"
                xcrun simctl list devices available
                echo ""
                echo "Simulator status:"
                xcrun simctl list devices 2>/dev/null | grep -A 2 -B 2 "$TVOS_NAME" || true
                exit 1
              fi

              echo "Waiting for simulator to be ready..."
              if ! xcrun simctl bootstatus "$TVOS_UDID" -b 2>&1; then
                echo "ERROR: Failed to wait for simulator boot status '$TVOS_NAME' (UDID: $TVOS_UDID)"
                echo "Available devices list:"
                xcrun simctl list devices available
                echo ""
                echo "Simulator status:"
                xcrun simctl list devices 2>/dev/null | grep -A 2 -B 2 "$TVOS_NAME" || true
                exit 1
              fi
            else
              echo "Simulator is already booted, skipping boot process"
            fi
          else
            echo "No UDID available, skipping boot (will use platform=name format)"
          fi

          echo "tvos_simulator=$TVOS_NAME" >> "$GITHUB_OUTPUT"
          echo "tvos_simulator_udid=$TVOS_UDID" >> "$GITHUB_OUTPUT"
          echo "Successfully configured tvOS Simulator: name='$TVOS_NAME' udid='${TVOS_UDID:-N/A}'"
          
      - name: Verify iOS Simulators
        if: matrix.target == 'ios'
        run: |
          echo "Available iOS Simulators:"
          xcrun simctl list devices available | grep -A 5 -B 5 "iOS" || true
          echo "Using simulator: ${{ steps.find_ios_simulator.outputs.ios_simulator_name }}"

      - name: Verify tvOS Simulators
        if: matrix.target == 'tvos'
        run: |
          echo "Available tvOS Simulators:"
          xcrun simctl list devices available | grep -A 5 -B 5 "tvOS" || true
          echo "Using simulator: ${{ steps.find_tvos_simulator.outputs.tvos_simulator }}"

      - name: Test macOS SPM
        if: matrix.target == 'macos' && matrix.build == 'spm'
        run: |
          swift test --configuration Debug \
            -Xswiftc -Xfrontend -Xswiftc -strict-concurrency=complete \
            -Xswiftc -Xfrontend -Xswiftc -warn-concurrency \
            -Xswiftc -Xfrontend -Xswiftc -enable-actor-data-race-checks \
            --enable-code-coverage

      - name: Test macOS Xcode
        if: matrix.target == 'macos' && matrix.build == 'xcode'
        run: xcodebuild test -scheme AsyncNet -destination "platform=macOS" CODE_SIGNING_ALLOWED=NO CODE_SIGNING_REQUIRED=NO

      - name: Test iOS
        if: matrix.target == 'ios'
        run: |
          DEST=$([ -n "${{ steps.find_ios_simulator.outputs.ios_simulator_udid }}" ] && echo "id=${{ steps.find_ios_simulator.outputs.ios_simulator_udid }}" || echo "platform=iOS Simulator,name=${{ steps.find_ios_simulator.outputs.ios_simulator_name }}")
          xcodebuild test -scheme AsyncNet -destination "$DEST" -destination-timeout 180 -sdk iphonesimulator CODE_SIGNING_ALLOWED=NO CODE_SIGNING_REQUIRED=NO

      - name: Test tvOS
        if: matrix.target == 'tvos'
        run: |
          DEST=$([ -n "${{ steps.find_tvos_simulator.outputs.tvos_simulator_udid }}" ] && echo "id=${{ steps.find_tvos_simulator.outputs.tvos_simulator_udid }}" || echo "platform=tvOS Simulator,name=${{ steps.find_tvos_simulator.outputs.tvos_simulator }}")
          xcodebuild test -scheme AsyncNet -destination "$DEST" -destination-timeout 180 -sdk appletvsimulator CODE_SIGNING_ALLOWED=NO CODE_SIGNING_REQUIRED=NO

      - name: Check coverage profdata
        if: matrix.target == 'macos' && matrix.build == 'spm'
        id: coverage_profdata_check
        run: |
          # Find the first .profdata file in the workspace
          PROFDATA_PATH=$(find . -name "*.profdata" -type f | head -1)
          
          if [ -n "$PROFDATA_PATH" ] && [ -f "$PROFDATA_PATH" ]; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
            echo "profdata_path=$PROFDATA_PATH" >> "$GITHUB_OUTPUT"
            echo "Found profdata at: $PROFDATA_PATH"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
            echo "No profdata files found"
          fi

      - name: Upload coverage profdata
        if: matrix.target == 'macos' && matrix.build == 'spm' && steps.coverage_profdata_check.outputs.exists == 'true'
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: coverage-profdata-${{ matrix.runner }}-${{ matrix.target }}-${{ matrix.build }}-xcode${{ matrix.xcode }}-swift${{ matrix.swift }}
          path: ${{ steps.coverage_profdata_check.outputs.profdata_path }}

# Note: iPadOS builds are not included because iPadOS and iOS have been unified
# Starting with iOS 18/iPadOS 18 (September 2024), Apple merged the platforms:
# - iPadOS SDK was discontinued
# - iPads now run iOS natively
# - Single iOS build covers both iPhone and iPad devices
# - No separate iPadOS target is needed in the matrix
